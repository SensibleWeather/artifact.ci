import {Webhooks} from '@octokit/webhooks'
import {NextRequest} from 'next/server'
import NextAuth, {type DefaultSession} from 'next-auth'
import DefaultGithub from 'next-auth/providers/github'
import {App, Octokit} from 'octokit'
import {z} from 'zod'
import {client, sql} from './db'
import {logger} from './tag-logger'

declare module 'next-auth' {
  /** Augmented - see https://authjs.dev/getting-started/typescript */
  interface Session {
    user: {
      github_login: string | null
    } & DefaultSession['user']
  }
}

export const GithubAppClientEnv = z.object({
  GITHUB_APP_CLIENT_ID: z.string().min(1),
  GITHUB_APP_CLIENT_SECRET: z.string().min(1),
})

export const GithubAppEnv = z.object({
  GITHUB_APP_ID: z.string().min(1),
  GITHUB_APP_PRIVATE_KEY: z.string().min(1),
})

export const WebhookEnv = z.object({
  GITHUB_APP_WEBHOOK_SECRET: z.string(),
})

const Github: typeof DefaultGithub = options => {
  const env = GithubAppClientEnv.parse(process.env)
  return DefaultGithub({
    ...options,
    clientId: env.GITHUB_APP_CLIENT_ID,
    clientSecret: env.GITHUB_APP_CLIENT_SECRET,
  })
}

export const {handlers, signIn, signOut, auth} = NextAuth({
  providers: [Github],
  callbacks: {
    async jwt({token, account}) {
      if (token.github_login && typeof token.github_login === 'string') {
        token.github_login_note = `jwt callback: github_login already set`
      } else if (account) {
        const octokit = new Octokit({auth: account.access_token})
        const {data: user} = await octokit.rest.users.getAuthenticated()
        token.github_login = user.login
        token.github_login_note = `jwt callback: added github_login`
      } else {
        token.github_login_note = `jwt callback: no account`
      }

      return token
    },
    async session({session, token}) {
      // typically session.user looks like {name: 'A B', email: undefined, image: 'https://.../something.jpg'}
      // typically token looks like {name: 'A B', picture: 'https://.../something.jpg', email: 'a@b.com', ...}
      session.user.github_login = token.github_login as string | null
      return session
    },
  },
})

export const getOctokitApp = () => {
  const env = GithubAppEnv.parse(process.env)
  return new App({appId: env.GITHUB_APP_ID, privateKey: env.GITHUB_APP_PRIVATE_KEY})
}

export const getInstallationOctokit = async (installationId: number) => {
  const app = getOctokitApp()
  return app.getInstallationOctokit(installationId)
}

export const getCollaborationLevel = async (
  octokit: Octokit,
  params: {owner: string; repo: string; username: string},
) => {
  if (params.username === params.owner) return 'admin'
  const {data: collaboration} = await octokit.rest.repos.getCollaboratorPermissionLevel(params)
  const parsed = z.object({permission: z.enum(['none', 'read', 'write', 'admin'])}).safeParse(collaboration)
  if (!parsed.success) logger.error({collaboration}, 'getCollaborationLevel: failed to parse collaboration')
  return parsed.success ? parsed.data.permission : 'none'
}

export const checkCanAccess = async (
  octokit: Octokit,
  params: {owner: string; repo: string; username: string; artifactId: string},
) => {
  const level = await getCollaborationLevel(octokit, params)
  if (level === 'none') {
    return {result: false, reason: `github access level: ${level}`} as const
  }

  const credits = await client.any(sql<queries.Credit>`
    select
      sponsor_id,
      coalesce(reason, 'artifact visibility: ' || a.visibility) as reason,
      a.id as artifact_id,
      a.name as artifact_name,
      a.visibility
    from usage_credits
    full outer join artifacts a on a.id = ${params.artifactId} and a.visibility = 'public'
    where github_login = ${params.username.toLowerCase()} or github_login = ${params.owner.toLowerCase()}
    and expiry > now()
  `)
  if (credits.length > 1) logger.warn({credits, params}, 'checkCanAccess: multiple credits')

  if (credits.length === 0) {
    return {result: false, reason: 'no credits'} as const
  }

  return {result: true, reason: credits.map(c => c.reason).join(';')} as const
}

/** Returns the JSON body of a GitHub webhook payload if the signature is valid, null otherwise. */
export const validateGithubWebhook = async (request: NextRequest, json?: string) => {
  json ??= await request.clone().text()
  const webhookEnv = WebhookEnv.parse(process.env)
  const webhooks = new Webhooks({secret: webhookEnv.GITHUB_APP_WEBHOOK_SECRET})
  const signature = request.headers.get('x-hub-signature-256') || ''
  logger.debug('validating webhook', {signature, secretLength: webhookEnv.GITHUB_APP_WEBHOOK_SECRET.length})
  return webhooks.verify(json, signature)
}

export declare namespace queries {
  // Generated by @pgkit/typegen

  /** - query: `select sponsor_id, coalesce(reason, 'art... [truncated] ... or github_login = $3 and expiry > now()` */
  export interface Credit {
    /** column: `public.usage_credits.sponsor_id`, regtype: `prefixed_ksuid` */
    sponsor_id: string | null

    /** regtype: `text` */
    reason: string | null

    /** column: `public.artifacts.id`, not null: `true`, regtype: `prefixed_ksuid` */
    artifact_id: import('~/db').Id<'artifacts'>

    /** column: `public.artifacts.name`, not null: `true`, regtype: `text` */
    artifact_name: string

    /** column: `public.artifacts.visibility`, not null: `true`, regtype: `text` */
    visibility: string
  }
}

name: upload artifact action
description: Drop in replacement for actions/upload-artifact which provides a browsable link to the artifact
inputs:
  path:
    description: A file, directory or wildcard pattern that describes what to upload
    required: true
  name:
    description: Name of the artifact to upload
    required: false
    default: artifact
  origin:
    description: The origin of the server to upload the artifact to
    required: false
    default: https://www.artifact.ci
  github-token:
    description: The GitHub token to use for the upload
    required: false
runs:
  using: composite
  steps:
    - shell: bash
      run: echo "::group::Upload artifact"
    - name: upload
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}
        path: ${{ inputs.path }}
    - name: print url
      shell: bash
      run: |
        echo 'View your artifact here:'
        echo '${{ inputs.origin }}/artifact/browse/${{ github.repository }}/${{ github.run_id }}/${{ inputs.name }}'
    - name: Checkout artifact.ci
      uses: actions/checkout@v4
      with:
        repository: mmkal/artifact.ci
        path: tmp/artifact.ci
    - name: install
      shell: bash
      run: corepack enable && pnpm install --silent
      working-directory: tmp/artifact.ci
    - name: patch @vercel/blob for debugging
      shell: bash
      working-directory: tmp/artifact.ci
      run: |
        node -v
        sed -i 's/const res = await _undici.fetch.call/console.log("client.cjs fetching", {url, options, event});const res = await _undici.fetch.call/g' node_modules/@vercel/blob/dist/client.cjs
        vercel_chunk_name=$(ls node_modules/@vercel/blob/dist | grep chunk | grep .cjs | grep -v .map)
        vercel_chunk_cjs="node_modules/@vercel/blob/dist/$vercel_chunk_name"
        echo "vercel_chunk_cjs: >>>$vercel_chunk_cjs<<<"
        sed -i 's/const apiResponse/const logFetch = (...args) => {console.log("apiResponse fetching", ...args, {a: args[1]?.headers?.authorization?.split(" ")}); return _undici.fetch(...args)}; const apiResponse/g' $vercel_chunk_cjs
        sed -i 's/_undici.fetch.call/logFetch.call/g' $vercel_chunk_cjs
        sed -i 's/res.ok/(res.ok || console.log(await res.clone().text(), res.url, res.status))/g' node_modules/@vercel/blob/dist/client.cjs
        sed -i 's/return clientToken/console.log({clientToken}); return clientToken/g' node_modules/@vercel/blob/dist/client.cjs
    - name: upload blob
      uses: actions/github-script@v6
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      with:
        script: |-
          console.log('context:::::', JSON.stringify(context, null, 2))
          const inputs = ${{ toJson(inputs) }}

          const cwd = process.cwd()
          process.chdir('tmp/artifact.ci')
          const dependencies = {
                fs: require('fs'),
                fsPromises: require('fs/promises'),
                mimeTypes: require('mime-types'),
                vercelBlobClient: require('@vercel/blob/client'),
                glob, // ambient variable available from actions/github-script
              }
          process.chdir(cwd)

          async function upload({context,inputs,dependencies}){const{glob,mimeTypes,fsPromises:fs,fs:fsSync,vercelBlobClient}=dependencies;const githubToken=inputs["github-token"];const pathPrefix="${{ github.repository }}/${{ github.run_id }}/"+inputs.name;const refName=context.ref.replace("refs/heads/","");console.log({refName,pathPrefix,inputs});if(pathPrefix.startsWith("mmkal/artifact.ci")&&refName!=="main"){const oldOrigin=inputs.origin;inputs.origin=`https://artifactci-git-${refName.replaceAll("/","-")}-mmkals-projects.vercel.app`;console.log(`uploading to ${inputs.origin} instead of ${oldOrigin} because ref is ${refName}`)}Object.assign(global,{window:{location:new URL(inputs.origin)}});const stat=await fs.stat(inputs.path).catch(e=>{if(e.code==="ENOENT")return null;throw e});const globPattern=stat?.isDirectory()?`${inputs.path}/**/*`:inputs.path;const globber=await glob.create(globPattern);const files=await globber.glob();const filesWithPathnames=files.flatMap(f=>{if(!fsSync.statSync(f).isFile())return[];const pathname=pathPrefix+f.replace(process.cwd(),"");return{localPath:f,viewUrl:`${inputs.origin}/artifact/blob/${pathname}`,pathname,contentType:mimeTypes.lookup(f)||"text/plain",multipart:false}});const pathnameToFile=new Map(filesWithPathnames.map(f=>[f.pathname,f]));const redactedContext={...context,runAttempt:Number(process.env.GITHUB_RUN_ATTEMPT),jobName:context.job,repository:process.env.GITHUB_REPOSITORY,githubOrigin:process.env.GITHUB_SERVER_URL,...{payload:null,payloadKeys:Object.keys(context.payload)}};const bulkRequest={type:"bulk",callbackUrl:`${inputs.origin}/artifact/upload/signed-url`,clientPayload:{githubToken,commit:{ref:context.ref,sha:context.sha,actions_run_id:context.runId.toString()},context:redactedContext},files:filesWithPathnames};console.log(`Sending bulk request to ${inputs.origin}/artifact/upload/signed-url (${filesWithPathnames.length} files)`,{redactedContext});const res=await fetch(`${inputs.origin}/artifact/upload/signed-url`,{method:"POST",body:JSON.stringify(bulkRequest),headers:{"content-type":"application/json","user-agent":"artifact.ci/action"}});const response=await res.clone().text();try{if(!res.ok)throw new Error(`failed to upload: ${res.status} ${response}`);const data=await res.json();for(const result of data.results){const file=pathnameToFile.get(result.pathname);if(!file)throw new Error(`file not found for pathname ${result.pathname}`);await vercelBlobClient.put(result.pathname,await fs.readFile(file.localPath),{access:"public",token:result.clientToken,multipart:file.multipart,contentType:file.contentType});console.log("Uploaded: "+file.viewUrl)}console.log("Upload complete");return}catch(e){console.log("response::::",res.status,response);console.log("error::::",e);throw e}}

          await upload({context, inputs, dependencies})
    - name: cleanup
      shell: bash
      run: rm -rf tmp/artifact.ci
